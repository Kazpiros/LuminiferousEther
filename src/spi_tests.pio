.pio_version 0
.program spi_duplex_with_irq
.side_set 1   ; 1 bit of sideset for SCLK

; Pin mapping (configured from C):
; - out_base  -> MOSI pin (use sm_config_set_out_pins)
; - in_base   -> MISO pin  (use sm_config_set_in_pins)
; - sideset   -> SCLK pin  (use sm_config_set_sideset_pins)
; - jmp_pin   -> IRQ pin   (use sm_config_set_jmp_pin)

.wrap_target
main_loop:
    jmp pin read_loop      side 0x2        ; if IRQ asserted -> go read continuous 32-bit words

    pull block             side 0x2        ; wait for a TX byte in TX FIFO (OSR loaded)
    mov y, osr             side 0x2        ; move tx byte to Y 
    mov isr, null          side 0x2        ; clear ISR for accumulating incoming bits
    set x, 7               side 0x2        ; bit counter (7..0)

duplex_bit:
    out pins, 1            side 0x1        ; put MSB of Y to MOSI (shifts Y right -> next bit ready)
    nop                    side 0x1        ; SCLK = 1 (sample edge)
    in pins, 1             side 0x0        ; sample MISO into ISR (shifts left)
    jmp x-- duplex_bit     side 0x0        ; SCLK = 0; loop 8 cycles

    push                   side 0x0        ; push ISR (8-bit received) to RX FIFO
    jmp main_loop          side 0x0


read_loop:
    ; We will sample 32 bits into ISR and push as one 32-bit word
    mov isr, null          side 0x0        ; clear ISR before sampling
    set x, 31              side 0x0        ; set bit counter for 32 bits
read32_bit:
    nop                    side 0x1        ; SCLK low
    nop                    side 0x1        ; SCLK high briefly; keep side 1 to show clock if desired
    in pins, 1             side 0x0        ; sample 1 bit from MISO into ISR (shift left)
    jmp x-- read32_bit     side 0x0        ; SCLK low between bits

    push                   side 0x0        ; push 32-bit ISR into RX FIFO
    jmp pin read_loop      side 0x0        ; if IRQ still high, sample another 32-bit word
    jmp main_loop          
.wrap


% c-sdk {
#include "hardware/gpio.h"
static inline void pio_spi_cs_init(PIO pio, uint sm, uint prog_offs, uint n_bits, float clkdiv
        uint pin_sck, uint pin_mosi, uint pin_miso, uint pin_irq) {
    pio_sm_config c = spi_duplex_with_irq_program_get_default_config(prog_offs);

    sm_config_set_out_pins(&c, pin_mosi, 1);
    sm_config_set_in_pins(&c, pin_miso);
    sm_config_set_sideset_pins(&c, pin_sck);
    sm_config_set_jmp_pin(&c, pin_irq)
    sm_config_set_out_shift(&c, false, true, n_bits);
    sm_config_set_in_shift(&c, false, true, n_bits);
    sm_config_set_clkdiv(&c, clkdiv);

    pio_sm_set_pins_with_mask(pio, sm, (2u << pin_sck), (3u << pin_sck) | (1u << pin_mosi));
    pio_sm_set_consecutive_pindirs(pio, sm, MOSI_PIN, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm, MISO_PIN, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, SCLK_PIN, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm, IRQ_PIN, 1, false);

    pio_gpio_init(pio, pin_mosi);
    pio_gpio_init(pio, pin_miso);
    pio_gpio_init(pio, pin_sck);
    pio_gpio_init(pio, pin_sck + 1);
    pio_gpio_init(pio, pin_irq);

    gpio_set_outover(pin_sck, cpol ? GPIO_OVERRIDE_INVERT : GPIO_OVERRIDE_NORMAL);
    hw_set_bits(&pio->input_sync_bypass, 1u << pin_miso);

    uint entry_point = prog_offs;
    pio_sm_init(pio, sm, entry_point, &c);
    pio_sm_exec(pio, sm, pio_encode_set(pio_x, n_bits - 2));
    pio_sm_exec(pio, sm, pio_encode_set(pio_y, n_bits - 2));
    pio_sm_set_enabled(pio, sm, true);
}
%}